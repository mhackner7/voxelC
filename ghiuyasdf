#include "chunk.h"
#include "noise.h"

#include "world.h"

#include <stdlib.h>

#define MAX_BLOCKS           (CHUNK_LENGTH * CHUNK_HEIGHT * CHUNK_LENGTH)
#define MAX_VERTEX_FLOATS    (72 * MAX_BLOCKS)
#define MAX_INDICES          (36 * MAX_BLOCKS)
#define MAX_UVS              (24 * MAX_BLOCKS)
#define MAX_NORMALS          (72 * MAX_BLOCKS)

typedef struct {
    f32 *vertices;
    u32 *indices;
    f32 *uvs;
    f32 *normals;

    u32  vertex_size;
    u32  index_size;
    u32  uv_size;
    u32  normal_size;

    u32  vertex_count;
    u32  index_count;
    u32  uv_count;
    u32  normal_count;
} Mesh_builder;

Mesh_builder *new_mesh_builder() {
    Mesh_builder *mb = malloc(sizeof(*mb));

    mb->vertex_size = MAX_VERTEX_FLOATS / 10;
    mb->index_size  = MAX_INDICES       / 10;
    mb->uv_size     = MAX_UVS           / 10;
    mb->normal_size = MAX_NORMALS       / 10;

    mb->vertex_count = 0;
    mb->index_count  = 0;
    mb->uv_count     = 0;
    mb->normal_count = 0;

    mb->vertices = malloc( sizeof(f32) * mb->vertex_size );
    mb->indices  = malloc( sizeof(u32) * mb->index_size  );
    mb->uvs      = malloc( sizeof(f32) * mb->uv_size     );
    mb->normals  = malloc( sizeof(f32) * mb->normal_size );
    
    return mb;
}

void mesh_ensure_capacity(Mesh_builder* mb) {

    if (mb->vertex_count + 10 == mb->vertex_size) {
        mb->vertex_size += MAX_VERTEX_FLOATS / 10;
        mb->vertices = realloc( mb->vertices, mb->vertex_size * sizeof(f32) );
    }

    if (mb->index_count + 10 == mb->index_size) {
        mb->index_size += MAX_INDICES / 10;
        mb->indices = realloc( mb->indices, mb->index_size * sizeof(u32) );
    }

    if (mb->uv_count + 10 == mb->uv_size) {
        mb->uv_size += MAX_UVS / 10;
        mb->uvs = realloc( mb->uvs, mb->uv_size * sizeof(f32) );
    }

    if (mb->normal_count + 10 == mb->normal_size) {
        mb->normal_size += MAX_NORMALS / 10;
        mb->normals = realloc( mb->normals, mb->normal_size * sizeof(f32) );
    }

}

void mesh_clamp(Mesh_builder* mb) {

    mb->vertices = realloc( mb->vertices, mb->vertex_count * sizeof(f32) );
    mb->indices  = realloc(  mb->indices,  mb->index_count * sizeof(u32) );
    mb->uvs      = realloc(      mb->uvs,     mb->uv_count * sizeof(f32) );
    mb->normals  = realloc(  mb->normals, mb->normal_count * sizeof(f32) );

}

void free_mesh_builder(Mesh_builder* mb) {  
    free( mb->vertices );
    free( mb->indices  );
    free( mb->uvs      );
    free( mb->normals  );
    free( mb );
}

static const f32 CUBE_VERTICES[] = {

    // looking at north face
    0, 0, 0,    
    0, 1, 0,    
    1, 1, 0,    
    1, 0, 0,    

    // south face
    1, 0, 1,    
    1, 1, 1,    
    0, 1, 1,    
    0, 0, 1,    

    // west face
    0, 0, 1,    
    0, 1, 1,   
    0, 1, 0,    
    0, 0, 0,    

    // east face
    1, 0, 0,    
    1, 1, 0,  
    1, 1, 1,   
    1, 0, 1,    

    // bottom face
    0, 0, 1, 
    0, 0, 0,    
    1, 0, 0,   
    1, 0, 1,    

    // top face
    0, 1, 0,   
    0, 1, 1,    
    1, 1, 1,    
    1, 1, 0,    
};

static const u32 CUBE_INDICES[36] = {
    //  Z-  north
    0, 1, 2,        2, 3, 0,
    //  Z+  south
    4, 5, 6,        6, 7, 4,
    //  X-  west
    8, 9, 10,       10, 11, 8,
    //  X+  east
    12, 13, 14,     14, 15, 12,
    //  Y-  down
    16, 17, 18,     18, 19, 16,
    //  Y+  up
    20, 21, 22,     22, 23, 20 
};

static const f32 CUBE_NORMALS[18] = {
     0.0f,  0.0f, -1.0f,   // Z-
     0.0f,  0.0f, +1.0f,   // Z+
    -1.0f,  0.0f,  0.0f,   // X-
    +1.0f,  0.0f,  0.0f,   // X+
     0.0f, -1.0f,  0.0f,   // Y-
     0.0f, +1.0f,  0.0f,   // Y+
};

void init_chunk(Chunk *chunk, u16 pos_x, u16 pos_z) {
    /** TEMPORARY
     * 
     * replace block generation for chunk with proper noise
     * just a test for the meshing
     * not intended for actual use
     * 
     */

     chunk->dirty = true;
     chunk->x = pos_x;
     chunk->z = pos_z;

    for (int x = 0; x < CHUNK_LENGTH; x++) {
        for (int y = 0; y < CHUNK_HEIGHT; y++) {
            for (int z = 0; z < CHUNK_LENGTH; z++) {

                u8 fourth = CHUNK_HEIGHT / 4;
                if (y <= fourth) 
                    chunk->blocks[x][y][z] = STONE;
                else if (y < 2 * fourth) 
                    chunk->blocks[x][y][z] = DIRT;
                else if (y == 2 * fourth)
                    chunk->blocks[x][y][z] = GRASS;
                else
                    chunk->blocks[x][y][z] = AIR;

            }
        }
    }

    clean_chunk(chunk);
}



static void add_face(f32 *vertices, u32 *indices, f32 *uvs, f32 *normals, u32 *vertex_count, u32 
    *index_count, u32 *uv_count, u32 *normal_count, Chunk *chunk, block_face face, u16 x, u16 y, u16 z) {

    BlockID block = chunk->blocks[x][y][z];

    u8 cube_offset = face * 4 * 3;
    u32 vertex_offset = *vertex_count / 3;

    static const u8 index_template[6] = { 0, 1, 2,      2, 3, 0, };
                    
    for (int i = 0; i < 12; i += 3) {
        vertices[ (*vertex_count)++ ] = CUBE_VERTICES[cube_offset + i + 0] + x + chunk->x;
        vertices[ (*vertex_count)++ ] = CUBE_VERTICES[cube_offset + i + 1] + y;
        vertices[ (*vertex_count)++ ] = CUBE_VERTICES[cube_offset + i + 2] + z + chunk->z;
    }

    for (int i = 0; i < 6; i++) {
        indices[ (*index_count)++ ] = index_template[i] + vertex_offset;
    }

    vec2 min;
    glm_vec2_copy(Block_Register[block].texmaps[face].min, min);
    vec2 max;
    glm_vec2_copy(Block_Register[block].texmaps[face].max, max);

    uvs[ (*uv_count)++ ] = min[0];
    uvs[ (*uv_count)++ ] = min[1];

    uvs[ (*uv_count)++ ] = min[0];
    uvs[ (*uv_count)++ ] = max[1];

    uvs[ (*uv_count)++ ] = max[0];
    uvs[ (*uv_count)++ ] = max[1];

    uvs[ (*uv_count)++ ] = max[0];
    uvs[ (*uv_count)++ ] = min[1];

    for (int i = 0; i < 4; i++)
        for (int k = 0; k < 3; k++)
            normals[ (*normal_count)++ ] = CUBE_NORMALS[ k + (face * 3) ];

}

static void make_buffer_objects(Chunk *chunk, f32 *vertices, u32 *indices, f32* uvs,
    f32 *normals, u32 vertex_count, u32 index_count, u32 uv_count, u32 normal_count) {

    glGenVertexArrays(1, &chunk->VAO);
    glBindVertexArray(chunk->VAO);

    glGenBuffers(1, &chunk->VBO);
    glBindBuffer(GL_ARRAY_BUFFER, chunk->VBO);
    glBufferData(
        GL_ARRAY_BUFFER, sizeof(f32) * vertex_count,
        vertices, GL_STATIC_DRAW
    );

    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);

    glGenBuffers(1, &chunk->UVBO);
    glBindBuffer(GL_ARRAY_BUFFER, chunk->UVBO);
    glBufferData(
        GL_ARRAY_BUFFER, sizeof(f32) * uv_count, 
        uvs, GL_STATIC_DRAW
    );
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, (void*)0);

    glGenBuffers(1, &chunk->NVBO);
    glBindBuffer(GL_ARRAY_BUFFER, chunk->NVBO);
    glBufferData(
        GL_ARRAY_BUFFER, sizeof(f32) * (normal_count), 
        normals, GL_STATIC_DRAW
    );
    glEnableVertexAttribArray(2);
    glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);

    glGenBuffers(1, &chunk->EBO);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, chunk->EBO);
    glBufferData(
        GL_ELEMENT_ARRAY_BUFFER, sizeof(u32) * index_count,
        indices, GL_STATIC_DRAW
    );

    glBindVertexArray(0);

    chunk->index_count = index_count;
}


void clean_chunk(Chunk *chunk) {
    if (!chunk->dirty) return;

    u32 vertex_count = 0, index_count = 0, 
        uv_count = 0, normal_count = 0,
        vertex_size = MAX_VERTEX_FLOATS / 10,
        index_size  = MAX_INDICES / 10,
        uv_size     = MAX_UVS / 10,
        normal_size = MAX_NORMALS / 10;

    f32 *vertices = (f32*) malloc( sizeof(f32) * vertex_size );
    u32 *indices  = (u32*) malloc( sizeof(u32) * index_size  );
    f32 *uvs      = (f32*) malloc( sizeof(f32) * uv_size     );
    f32 *normals  = (f32*) malloc( sizeof(f32) * normal_size );

    // when done testing single chunk add checks for adjacent chunks

    for (int x = 0; x < CHUNK_LENGTH; x++) {
        for (int y = 0; y < CHUNK_HEIGHT; y++) {
            for (int z = 0; z < CHUNK_LENGTH; z++) {

                if (vertex_count + 10 == vertex_size) {
                    vertex_size += MAX_VERTEX_FLOATS / 10;
                    vertices = realloc( vertices, vertex_size * sizeof(f32) );
                }

                if (index_count + 10 == index_size) {
                    index_size += MAX_INDICES / 10;
                    indices = realloc( indices, index_size * sizeof(u32) );
                }

                if (uv_count + 10 == uv_size) {
                    uv_size += MAX_UVS / 10;
                    uvs = realloc( uvs, uv_size * sizeof(f32) );
                }

                if (normal_count + 10 == normal_size) {
                    normal_size += MAX_NORMALS / 10;
                    normals = realloc( normals, normal_size * sizeof(f32) );
                }

                if (chunk->blocks[x][y][z] == AIR) continue;


                if (x + 1 >= CHUNK_LENGTH || chunk->blocks[x + 1][y][z] == AIR)
                    add_face(
                        vertices, indices, uvs, normals,
                        &vertex_count, &index_count, 
                        &uv_count, &normal_count,
                        chunk, face_east,
                        x, y, z
                    );

                if (x - 1 < 0 || chunk->blocks[x - 1][y][z] == AIR) 
                    add_face(
                        vertices, indices, uvs, normals,
                        &vertex_count, &index_count, 
                        &uv_count, &normal_count,
                        chunk, face_west,
                        x, y, z
                    );

                if (y + 1 >= CHUNK_HEIGHT || chunk->blocks[x][y + 1][z] == AIR) 
                    add_face(
                        vertices, indices, uvs, normals,
                        &vertex_count, &index_count,
                        &uv_count, &normal_count,
                        chunk, face_up,
                        x, y, z
                    );

                if (y == 0 || chunk->blocks[x][y - 1][z] == AIR) 
                    add_face(
                        vertices, indices, uvs, normals,
                        &vertex_count, &index_count, 
                        &uv_count, &normal_count,
                        chunk, face_down,
                        x, y, z
                    );

                if (z + 1 >= CHUNK_LENGTH || chunk->blocks[x][y][z + 1] == AIR) 
                    add_face(
                        vertices, indices, uvs, normals,
                        &vertex_count, &index_count, 
                        &uv_count, &normal_count,
                        chunk, face_south,
                        x, y, z
                    );

                if (z - 1 < 0 || chunk->blocks[x][y][z - 1] == AIR) 
                    add_face(
                        vertices, indices, uvs, normals,
                        &vertex_count, &index_count, 
                        &uv_count, &normal_count,
                        chunk, face_north,
                        x, y, z
                    );
                            
            }
        }
    }


    vertices = realloc( vertices, vertex_count * sizeof(f32) );
     indices = realloc(  indices,  index_count * sizeof(u32) );
         uvs = realloc(      uvs,     uv_count * sizeof(f32) );
     normals = realloc(  normals, normal_count * sizeof(f32) );

    make_buffer_objects(
        chunk, vertices, indices, uvs, normals, 
        vertex_count, index_count, uv_count, normal_count
    );

    chunk->dirty = false;

    free(vertices);
    free(indices);
    free(uvs);
    free(normals);
}

void render_chunk(Chunk *chunk) {
    glBindVertexArray(chunk->VAO);
    glDrawElements(
        GL_TRIANGLES, chunk->index_count, GL_UNSIGNED_INT, (void*)0
    );
    //printf("Rendering chunk at %d,%d with %d indices\n", chunk->x, chunk->z, chunk->index_count);

}

void free_chunk(Chunk *chunk) {
    if (chunk) {
        free(chunk);
    }
    glDeleteVertexArrays(1, &chunk->VAO);
    glDeleteBuffers(1, &chunk->VBO);
    glDeleteBuffers(1, &chunk->EBO);
}